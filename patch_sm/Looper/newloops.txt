#include "daisy_patch_sm.h"
#include "daisysp.h"
using namespace daisy;
using namespace patch_sm;
using namespace daisysp;
DaisyPatchSM hw;
Switch       button1;
Switch       button2, button3;
//#define LoopKnobber CV_1
float rel1;
//#define LoopKnobber CV_5
#define freq1Knob ADC_9
#define cvLFOFreq CV_8
//#define freq1Knob CV_8
int loopLength1 = 0;
int loopLength2 = 0;
//ReverbSc reverb;

#define LoopKnobber ADC_11
#define verbKnob ADC_10
#define relKnob CV_6
#define attck1Knob ADC_12
float     count = 0.f;
Resonator rez;
GPIO      my_led1;
GPIO      my_led2;
float     rezOn = 0.f;
// Initialize it to pin D1 as an OUTPUT
//static float send;

Adsr env1;
Adsr env2;


////SyntheticBassDrum  bd;
//SyntheticSnareDrum snr;
Oscillator lfo1, lfo2, lfo3;
int        freq_multiplier = 1;
bool       gateTrigger     = 0;
bool       flip1           = 0;
bool       flip2           = 0;
float      decay           = 0.001f;
bool       flip3           = 0;
bool       flip4           = 0;
// Define these constants for better management of magic numbers
constexpr float  kGainReduction = 0.75f;
constexpr int    kHoldTimeMS    = 1000;
constexpr size_t kBuffSize      = 48000 * 100; // 45 seconds at 48kHz
Looper           looper1, looper2;
static DcBlock   blk[2];

int                 seqCount = 0;
float DSY_SDRAM_BSS buffer_1[kBuffSize];
float DSY_SDRAM_BSS buffer_2[kBuffSize];

// Global or static variables to maintain state
volatile bool isLooping1    = false;
static int    triggerCount1 = 0;
volatile bool isArmed1      = false;
volatile bool isLooping2    = false;
static int    triggerCount2 = 0;
volatile bool isArmed2      = false;
int           loopLength    = 8;


/*
struct sampHoldStruct
{
    SampleHold       sampHold;
    SampleHold::Mode mode;
    float            output;

    void Process(bool trigger, float input)
    {
        output = sampHold.Process(trigger, input, mode);
    }
};


sampHoldStruct sampHolds[2];
*/


int   dot                  = 0;
float presetAttackTimes[]  = {0.001f,
                             0.002f,
                             0.0042f,
                             0.00483f,
                             0.005f,
                             0.006f,
                             0.007f,
                             0.008f,
                             0.009f,
                             0.01f,
                             0.01f,
                             0.014f,
                             0.02f,
                             0.025f,
                             .03f,
                             .035f,
                             0.083f,

                             .09f,
                             .1f};
float presetDecayTimes[]   = {0.05f,
                            0.07f,
                            0.078f,
                            0.086f,
                            0.09f,
                            0.095f,
                            0.12f,
                            0.13f,
                            0.14f,
                            0.15f,
                            0.17f,
                            0.24f,
                            0.27f,
                            0.34f,
                            0.35f,
                            0.4F,
                            0.43f,
                            .5f,
                            .55f};
float presetReleaseTimes[] = {0.07f,
                              0.085f,
                              0.12f,
                              0.15f,
                              0.17f,
                              0.2f,
                              0.22f,
                              .25f,
                              .27f,
                              .286f,
                              0.29f,
                              .299f,
                              0.3f,
                              .33f,
                              0.38f,
                              0.35f,
                              .4f,
                              .5f,
                              .65f};

void IncrementAndWrapInt(int& count, int maxSize)
{
    count++;
    if(count > maxSize)
    {
        count = 0;
    }
}

void IncrementAndWrapFloat(float& count,
                           float  minSize,
                           float  maxSize,
                           float  incrementSize)
{
    count += incrementSize;
    if(count > maxSize)
    {
        count = minSize;
    }
}


void looperLength(float mode, int& loopLength)
{
    if(mode < .5f)
    {
        loopLength = 64;
    }
    else if(mode < 1.5f)
    {
        loopLength = 16;
    }
    else if(mode < 2.75f)
    {
        loopLength = 8;
    }
    else if(mode < 4.5f)
    {
        loopLength = 4;
    }
    else if(mode < 5.0f)
    {
        loopLength = 2;
    }
}

struct sampHoldStruct
{
    SampleHold       sampHolds;
    SampleHold::Mode mode;
    float            output;

    void Process(bool trigger, float input, SampleHold::Mode mode)
    {
        output = sampHolds.Process(trigger, input, mode);
    }
};

void envelopePresets(int currentPreset, Adsr& env)
{
    env.SetAttackTime(presetAttackTimes[currentPreset]);
    env.SetTime(ADSR_SEG_DECAY, presetDecayTimes[currentPreset] + rel1 * .2f);
    env.SetTime(ADSR_SEG_RELEASE,
                presetReleaseTimes[currentPreset] + rel1 * .3f);
}
sampHoldStruct sampHolds[2];


bool  modeSwitch = 0;
float structure, loopKnob1, loopKnob2, lfofreq;
bool  switchy;

void EnvelopeCallback(uint16_t** output, size_t size)
{
    structure = 1.f - hw.GetAdcValue(ADC_11);

    //  float cvraw1     = hw.GetAdcValue(CV_1) + 0.028;
    //  float cvraw1     = hw.GetAdcValue(CV_1) + 0.028;
    bool env_state1 = hw.gate_in_1.State();
    bool env_state2 = hw.gate_in_2.State();
    // bool env_state2 = hw.gate_in_2.State();
    //  float cvraw1     = hw.GetAdcValue(CV_1) + 0.028;
    //  float cvraw7     = hw.GetAdcValue(CV_7) + 0.029;
    // float cv8 = hw.GetAdcValue(CV_8) + 0.028;
    // float cvraw6     = hw.GetAdcValue(CV_6) + 0.032;
    float cv4 = hw.GetAdcValue(CV_4) + 0.028f;

    rel1 = 1.f - (hw.GetAdcValue(ADC_11));

    int cv1PresetIndex = static_cast<int>(cv4 * 18.0f);
    int cv2PresetIndex = static_cast<int>(cv4 * 18.f);

    envelopePresets(cv1PresetIndex, env1);
    envelopePresets(cv2PresetIndex, env2);

    loopKnob1 = hw.GetAdcValue(ADC_10);
    looperLength(loopKnob1 * 5.f, loopLength1);

    loopKnob2 = hw.GetAdcValue(ADC_9);
    looperLength(loopKnob2 * 5.f, loopLength2);


    for(size_t i = 0; i < size; i++)

    {
        output[0][i] = env1.Process(env_state1) * 4095.0f;
        output[1][i] = env2.Process(env_state2) * 4095.0f;
    }
}

/**
 * Handles button interactions for triggering different looper functionalities.
 * 
 * This function checks the state of two buttons to control a looper's behavior.
 * It includes functionalities for starting/stopping recording, arming the looper,
 * clearing the loop, and cycling through looper modes.
 */
void buttons()
{
    // Check for the rising edge on button1 to either trigger recording or arm the looper.
    if(button2.RisingEdge())
    {
        // If already looping, trigger recording.
        if(isLooping1)
        {
            looper1.TrigRecord();
        }
        // If not looping, set the looper as armed.
        else
        {
            isArmed1 = true;
        }
    }


    if(button2.TimeHeldMs() > (500.f))
    {
        looper1.Clear();
        isLooping1    = false;
        triggerCount1 = 0;
        isArmed1      = false;
    }


    if(button1.RisingEdge())
    {
        lfo1.SetAmp(structure);
    }
    if(button1.TimeHeldMs() > (550.f))
    {
        switchy = !switchy;
        if(switchy)
        {
            rezOn = 1.f;
        }
        else
        {
            rezOn = 0.f;
        }
    }

    if(button3.Pressed() && button2.Pressed())
    {
        lfo1.SetFreq(structure * .5f);
    }

    if(button3.RisingEdge())
    {
        looper1.IncrementMode();
        //looper2.IncrementMode();


        // If the new mode is REPLACE or NORMAL, increment mode again.
        if((looper1.GetMode() == Looper::Mode::REPLACE)
           || (looper1.GetMode() == Looper::Mode::NORMAL))
        {
            looper1.IncrementMode();
            //  looper2.IncrementMode();
        }
    }
    //   my_led2.Write(looper2.Recording());
    my_led1.Write(looper1.Recording());


    if(looper1.IsNearBeginning())

    {
        my_led1.Write(true);
    }
}
/**
 * Processes audio input and applies effects based on user interactions and control states.
 * 
 * This function is designed to be called as an audio callback, which processes blocks of audio
 * samples. It handles button debouncing, gate triggering for recording, and applies a looping effect
 * with variable feedback based on external controls. Additionally, it applies a reverb effect to the
 * processed audio.
 * 
 * @param in Input buffer containing the incoming audio samples.
 * @param out Output buffer where the processed audio samples are stored.
 * @param size The number of audio samples in the input and output buffers.
 */
void AudioCallback(AudioHandle::InputBuffer  in,
                   AudioHandle::OutputBuffer out,
                   size_t                    size)
{
    hw.ProcessAllControls();
    button1.Debounce();
    button2.Debounce();
    button3.Debounce();


    buttons();
    gateTrigger = hw.gate_in_1.Trig();
    if(gateTrigger)
    {
        if(isArmed1)
        {
            if(!isLooping1)
            {
                looper1.TrigRecord();
                isLooping1    = true;
                triggerCount1 = 1;
            }
            else if(++triggerCount1 > loopLength1)
            {
                looper1.TrigRecord();
                triggerCount1 = 0;
                isArmed1      = false;
            }
        }
        if(isArmed2)
        {
            if(!isLooping2)
            {
                looper2.TrigRecord();
                isLooping2    = true;
                triggerCount2 = 1;
            }
            else if(++triggerCount2 > loopLength2)
            {
                looper2.TrigRecord();
                triggerCount2 = 0;
                isArmed2      = false;
            }
        }
    }

    for(size_t i = 0; i < size; i++)
    {
        bool env_state1 = hw.gate_in_1.State();

        rez.SetFreq();
        rez.SetStructure((structure * .75f) + .1f);
        rez.SetDamping((loopKnob1 * .8f) + .1f);
        rez.SetBrightness((loopKnob2 * 7.f) + .2f);
        float inL   = IN_L[i];
        float inR   = inL;
        float loop1 = looper1.Process(inL);
        float rezo  = rez.Process(inR);
        //float loop2    = looper2.Process(inR);
        float softLoop = SoftClip((loop1 + rezo) * .75);


        OUT_R[i] = softLoop;
        OUT_L[i] = softLoop;
        ;
    }
}
float frac;

int main(void)
{
    // Initialize and check for errors
    hw.Init();

    // Start the audio callback
    hw.StartAudio(AudioCallback);
    hw.StartDac(EnvelopeCallback);

    looper1.Init(buffer_1, kBuffSize);
    // looper2.Init(buffer_2, kBuffSize);
    env1.Init(hw.AudioSampleRate());
    env2.Init(hw.AudioSampleRate());

    float sample_rate = hw.AudioSampleRate();

    ///verb.Init(sample_rate);
    /// verb.SetFeedback(0.85f);
    /// verb.SetLpFreq(18000.0f);

    lfo1.Init(sample_rate);
    lfo2.Init(sample_rate);
    lfo1.SetFreq(1.f); // Set initial frequency for LFO1
    lfo2.SetAmp(.75f);
    lfo1.SetWaveform(Oscillator::WAVE_TRI);
    lfo2.SetWaveform(Oscillator::WAVE_SIN);

    lfo1.SetAmp(1.);
    blk[0].Init(sample_rate);


    my_led1.Init(hw.D2, GPIO::Mode::OUTPUT);
    my_led2.Init(hw.D3, GPIO::Mode::OUTPUT);


    rez.Init(.015, 24, sample_rate);
    rez.SetBrightness(.5f);
    rez.SetDamping(.5f);
    rez.SetStructure(.5f);
    button1.Init(hw.D1);
    button2.Init(hw.D10);
    button3.Init(hw.D5);
    looper1.SetMode(Looper::Mode::ONETIME_DUB);
    looper2.SetMode(Looper::Mode::ONETIME_DUB);
    frac = 1.f / RAND_MAX;


    while(1) {}
}
